第一部分：自动内存管理机制

第2章 java内存区域与内存溢出异常
一、运行时数据区域
(1) 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。
    解析执行时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。

    由于java虚拟机的多线程是通过线程轮流切换并分配处理执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令
    因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间计数器互不影响。所有线程私有的内存
``
    注意：
    如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
    如果正在执行的是Native方法，这个计数器值为空。
    是唯一一个没有OutOfMemoryError的区域

(2) java虚拟机栈 : java方法执行的内存模型
    1、java虚拟机栈:也是线程私有的。
        每个方法在执行的同时都会创建一个栈帧用于存放局部变量表，操作数栈，动态链接，方法出口的信息

        局部变量表存放了编译期可知的各种基本数据类型和对象引用
            其中64位长度的long和double类型的数据会占用2个局部变量空间
            其余的数据类型只占用1个。
            所需的内存空间在编译期间完成分配,运行期间不会改变局部变量表的大小

    2、可能发生两种异常:
        如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;
        如果虚拟机栈可以动态扩展，当扩展无法申请到足够的内存，就会抛出OutOfMemoryError异常

(3) 本地方法栈 : 虚拟机使用到的Native方法服务。

(4) Java堆: 线程共享,内存最大
    目的就是存放对象实例，几乎所有的对象实例都在这里分配内存(注意CLASS对象的实例，是在方法区中)
    Java堆是垃圾收集器的主要区域，因此很多时候也被做"GC堆"
    由于现在垃圾收集器采用分代收集算法，所以java堆中还可以细分为：新生代和老年代

(5) 方法区:各个线程共享的内存区域
    用于存储已被虚拟机加载的类信息，常量，静态变量，(JIT)即时编译器编译后的代码等数据。

(6) 运行时常量池 ：各个线程共享
    Class文件中除了有类的版本、字段、方法、接口等信息。还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。

(7) 直接内存： 不是虚拟机运行时数据区的一部分
    它可以使用Native函数库直接分配的堆外内存，然后通过一个存储在java堆中的DirectByBuffer对象作为这块内存的引用进行操作
    避免了再java堆和Native堆中来回复制数据

二、HotSpot虚拟机对象探秘
(1) 对象创建
    第一步：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否在常量池中定位一个类的符号引用，并且检查这个符号引用代表的类是否被加载过
如果没有，先执行相应的类加载过程
    第二步：类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成后便可以确定。
    1、java堆内存是规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，每次分配内存是把指针向空闲那边移动，这种分配的方式称为指针碰撞
    2、不规整，已使用的内存和空闲的内存相互交错，虚拟机必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配的方式称"空闲列表"
    java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
        使用Serial、 ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，
        使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表
    分配内存并发问题：采用两种方式
        1、对分配内存空间的动作进行同步处理
        2、把内存分配的任务按照线程划分在不同的空间之中进行

    第三步：内存分配完成后，设置对象进必要的信息
        例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息

(2)对象的内存布局
    对象在内存中存储的布局可以分为：对象头，实例数据和对齐填充
    对象头包括
        用于存储对象自身的运行时数据：如哈希码，GC分代年龄，锁状态标示，线程持有的锁，偏向线程ID，偏向时间戳。
        用于存储类型指针：对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例。
        用于对齐填充的占位符

(3)对象的访问定位:访问方式有使用句柄和直接指针两种
    使用句柄 : 句柄池包括了到对象实例数据的指针，也包括了到对象类型数据的指针。
               对象类型数据的指针和对象的实例数据是分开。
    直接指针 : 对象类型数据的指针和对象的实例数据在一起

(4)OutOfMemoryError异常
    1、Java堆溢出:
        Java堆用于存储对象实例，只要不断地创建对象，并且保证GC  ROOTs到对象之间有可达路径来避免垃圾回收机制清除这些对象。
        异常信息：“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。
        通过调整虚拟机的堆参数(-Xmx与-Xms)来设置堆内存大小。

        内存溢出与内存泄露
        内容溢出：是指程序在申请内存时，没有足够的内存空间供其使用
        内存泄露：是指程序在申请内存后，无法释放已申请的内存空间
        内存泄露最终会导致内存溢出。

    2、java虚拟机栈和本地方法栈溢出
        当递归深度很大时候，就有可能发生栈的溢出。
        异常信息： StackOverflowError
        栈容量只由-Xss参数 : 设置栈的大小
        1、如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
        2、虚拟机栈和本地方法栈的大小： 本机内存-减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量）
        3、在多线程开发时注意：每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽

        如果虚拟机在扩展是无法申请到足够的内存空间，则抛出OutOfMemberError异常

    3、方法区和运行时常量池溢出
       方法区用于存放Class的相关信息，如类名、 访问修饰符、 常量池、 字段描述、 方法描述等
       当前的很多主流框架，如Spring、 Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存
       当经常动态生成大量Class时，可以会发生异常
       方法区异常：PermGen space
       通过-XX：PermSize和-XX：MaxPermSize限制方法区大小

    4、本机直接内存溢出
        通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样

第3章 垃圾收集器与内存分配策略
(2) 对象是否存活
    1、引用计数算法
        Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题

    2、可达性分析算法
        通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），
        当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用。
    3、引用
        强引用（Strong Reference）
            类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
        软引用（Soft Reference）： 并非必需的对象
            在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收
        弱引用（Weak Reference）
            弱引用关联的对象只能生存到下一次垃圾收集发生之前
        虚引用（Phantom Reference）
            无法通过虚引用来取得一个对象实例

    4 生存还是死亡
        即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。
        如果在第1次标记时，没有标记清除，引用链上的任何一个对象建立关联即可。否则，就会被清除。

    5 回收方法区
        永久代的垃圾收集主要回收两部分内容 ：废弃常量和无用的类

(3) 垃圾收集算法
1、标记-清除算法 ：
   首先标记出所有需要回收的对象，在标记完成后统一清除所有被标记的对象
   主要不足有两个：
        一个是效率问题，标记和清除两个过程的效率都不高；
        另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，
        无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

2、复制算法(新生代)
   它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉
   主要不足:代价比较高： 将内存缩小为了原来的一半，未免太高了一点

   HotSpot虚拟机默认将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
   HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。
   Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion)

3、标记-整理算法（老年代）
    “标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，
    但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

4、分代收集算法:根据各个年代的特点采用最适当的收集算法
    把Java堆分为新生代和老年代，这样就可以。
    新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要"付出少量存活对象的复制成本"就可以完成收集。
    老年代中因为对象存活率高、 没有额外空间对它进行分配担保，就必须使用“标记―清理”或者“标记―整理”算法来进行回收

(4) HotSpot的算法实现
    1、枚举根节点 ： 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举
    2、安全点：只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停
       有两种方案：抢先式中断（Preemptive Suspension）和主动式中断
        在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。
    3、安全区域：对于Sleep状态的线程，无法响应JVM的中断请求，进入安全点，所以要使用安全区域
       在这个区域中的任意地方开始GC都是安全的。 我们也可以把Safe Region看做是被扩展了的Safepoin

(5) 垃圾收集器
并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
(1)新生代
    1、Serial收集器：
        这个收集器是一个单线程的收集器，它只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且在它进行垃圾收集时，必须停止其他所有的工作线程，直到它收集结束
    2、ParNew收集器：
        ParNew收集器其实就是Serial收集器的多线程版本。只是GC是多线程处理，也会停顿用户线程
    3、Parallel Scavenge收集器目标是达到一个可控制的吞吐量。
        所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值.
(2)老年代
    1 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法
    2 Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法
    *3 CMS收集器：是基于“标记―清除”算法实现的
        CMS收集器的运作步骤：
        初始标记: 暂停所有的其他线程，并记录下直接与root相连的对象
        并发标记: 开启GC和用户线程,并进行GC RootsTracing的过程
        重新标记: 暂停所有的其他线程,修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
        并发清除: 开启GC和用户线程,清除重新标记后的对象。

    *4 G1: 是基于“标记―整理”算法(没有区分新生代和老年代)
        G1收集器的运作大致可划分为以下几个步骤：
        初始标记（Initial Marking）
        并发标记（Concurrent Marking）
        最终标记（Final Marking）
        筛选回收（Live Data Counting and Evacuation）

(6) 内存分配与回收策略
http://www.open-open.com/lib/view/open1429883238291.html
1 对象优先在Eden分配
    当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC
    新生代GC（Minor GC）：
        指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
    老年代GC（Major GC/Full GC）：
        指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。
    Major GC的速度一般会比Minor GC慢10倍以上。

2 大对象直接进入老年代(Tenured/Old )
    虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配
    这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制

3 长期存活的对象将进入老年代(Tenured/Old )
    虚拟机给每个对象定义了一个对象年龄（Age）计数器
    如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。
    对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中

4 动态对象年龄判定
    如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，
    年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

5 空间分配担保
    在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。
    如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。
    如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
    如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；
    如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC

6 补充内存：Minor GC、Major GC和Full GC之间的区别
(1) Minor GC : 每次 Minor GC 会清理年轻代的内存

(2) Major GC vs Full GC
    Major GC 是清理永久代。
    Full GC 是清理整个堆空间―包括年轻代和永久代。


第4章 虚拟机性能监控与故障处理工具
https://mp.weixin.qq.com/s/QNr8somjodyvU9dRAQG2oA
一、JDK的命令行工具
1、jps -lvm：虚拟机进程状况工具

2、jstat 是用于监视虚拟机各种运行状态信息的命令行工具
-class 监视类装载、卸载数量、总空间以及类装载所耗费的时间
-gc 监视java堆状况，包括Eden区，两个surivor区，老年代，永久代等的容量，已用空间，GC时间合计等信息
-gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比
-t 加上-t，表示添加时间戳
 S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT
0.00  50.00   2.31  41.19  42.50    871   24.682     1    0.087   24.768

jstatd -J-Djava.security.policy=jstatd.all.policy -p 10003 &

查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了2.31%的空间，两个Survivor区（S0、 S1，表示Survivor0、 Survivor1）里面都是空的，
老年代（O，表示Old）和永久代（P，表示Permanent）则分别使用了41.19%和42.50%的空间。
程序运行以来共发生Minor GC（YGC，表示Young GC）871次，总耗时24.682秒，发生Full GC（FGC，表示FullGC）1次，
Full GC总耗时（FGCT，表示Full GC Time）为0.087秒，所有GC总耗时（GCT，表示GC Time）为24.768秒。

3、jinfo：作用是实时地查看和调整虚拟机各项参数

4 jmap: 命令用于生成堆转储快照
  jmap -heap 30772 查看堆信息

5 jhat的分析结果

6 jstack  命令用于生成虚拟机当前时刻的线程快照
jstack命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump 或javacore 文件）。
生成线程快照的主要目的是定位线程长时间停顿的原因，如线程间死锁，死循环，请求外部资源导致长时间等待都是导致线程长时间停顿的常见原因
参数
-F 当正常输出的请求不被响应时，强制输出线程堆栈
-l 除堆栈外，显示关于锁的附加信息
-m 如果调用到本地方法的话，可以显示C的堆栈

二 JDK的可视化工具

第二部分：虚拟机执行子系统
各种不同平台的虚拟机与所有平台都统一使用的程序存储格式――字节码

1  Class类文件的结构:http://blog.csdn.net/a19881029/article/details/16117251
   Class文件是一组以8位字节为基础单位的二进制流

   Class文件格式只有两种数据类型:无符号数和表
     无符号数属于基本的数据类型，以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个字节的无符号数，
     可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串值。

     表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。

   (1) 魔数与Class文件
       每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件
       紧接着魔数的4个字节存储的是Class文件的版本号：
       第5和第6个字节是次版本号（Minor Version）;
       第7和第8个字节是主版本号（Major Version）。

   (2) 常量池：
      常量池容量计数器:constant_pool_count: 在常量池的入口需要放置一项u2类型的数据。

      常量池:存放字面量和符号引用
         字面量比较接近于Java语言层面的常量概念，如文本字符串、 声明为final的常量值等。

         符号引用则属于编译原理方面的概念，包括了下面三类常量：
            类和接口的全限定名,字段的名称和描述符,方法的名称和描述符

            符号引用不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，
            也就无法直接被虚拟机使用。
            当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、 翻译到具体的内存地址之中.

      常量池的项目类型： 一共包含14种项目类型，并且每个项目类型都有自己的数据结构

   (3) 访问标识(access_flags)
      这个标志用于识别一些类或者接口层次的访问信息:
      包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。

   (4) 类索引、父类索引与接口索引的集合
       类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，
       Class文件中由这三项数据来确定这个类的继承关系

   (5) 字段表集合
       字段表（field_info）用于描述接口或者类中声明的变量。 字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量

   (6) 方法表集合
       用于描述接口或类中声明的方法

   (7) 属性表集合
       在Class文件、 字段表、 方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息

2 字节码指令简介
    在字节码文件(Class文件中) ， Java虚拟机的指令由操作码+操作数组成。

(1) 字节码与数据类型
    i代表对int类型的数据操作，l代表long,s代表short,b代表byte,c代表char,f代表float,d代表double,a代表reference

(2) 加载和存储指令: 加载和存储指令用于将数据在栈帧中的"局部变量表"和"操作数栈"（见第2章关于内存区域的介绍）之间来回传递
    将一个局部变量加载到操作栈(从局部变量表)：
        iload、 iload_＜n＞、 lload、 lload_＜n＞、 fload、 fload_＜n＞、 dload、 dload_＜n＞、 aload、 aload_＜n＞。
    将一个数值从操作数栈存储到局部变量表：
        istore、 istore_＜n＞、 lstore、 lstore_＜n＞、fstore、 fstore_＜n＞、 dstore、 dstore_＜n＞、 astore、 astore_＜n＞。
    将一个常量加载到操作数栈：
        bipush、 sipush、 ldc、 ldc_w、 ldc2_w、 aconst_null、iconst_m1、 iconst_＜i＞、 lconst_＜l＞、 fconst_＜f＞、 dconst_＜d＞。
    扩充局部变量表的访问索引的指令：wide。

(3)运算指令 : 运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶
    加法指令：iadd、 ladd、 fadd、 dadd。
    减法指令：isub、 lsub、 fsub、 dsub。
    乘法指令：imul、 lmul、 fmul、 dmul。
    除法指令：idiv、 ldiv、 fdiv、 ddiv。
    求余指令：irem、 lrem、 frem、 drem。
    取反指令：ineg、 lneg、 fneg、 dneg。
    位移指令：ishl、 ishr、 iushr、 lshl、 lshr、 lushr。
    按位或指令：ior、 lor。
    按位与指令：iand、 land。
    按位异或指令：ixor、 lxor。
    局部变量自增指令：iinc。
    比较指令：dcmpg、 dcmpl、 fcmpg、 fcmpl、 lcmp。

(4) 类型转换指令 : 类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作
    宽化类型转换: 直接支持,不需要指令来完成
        int类型到long、 float或者double类型。long类型到float、 double类型。float类型到double类型。

    窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成.
        这些转换指令包括：i2b、 i2c、 i2s、 l2i、 f2i、 f2l、 d2i、 d2l和d2f。
        转换过程很可能会导致数值的精度丢失。

(5) 对象创建与访问指令
    创建类实例的指令：new。
    创建数组的指令：newarray、 anewarray、 multianewarray。
    访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、 putfield、 getstatic、 putstatic。
    把一个数组元素加载到操作数栈的指令：baload、 caload、 saload、 iaload、 laload、faload、 daload、 aaload。
    将一个操作数栈的值存储到数组元素中的指令：bastore、 castore、 sastore、 iastore、fastore、 dastore、 aastore。
    取数组长度的指令：arraylength。
    检查类实例类型的指令：instanceof、 checkcast。

(6) 操作数栈管理指令
    将操作数栈的栈顶一个或两个元素出栈：pop、 pop2。
    复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、 dup2、dup_x1、 dup2_x1、 dup_x2、 dup2_x2。
    将栈最顶端的两个数值互换：swap。

(7) 控制转移指令
    条件分支：ifeq、 iflt、 ifle、 ifne、 ifgt、 ifge、 ifnull、 ifnonnull、 if_icmpeq、 if_icmpne、if_icmplt、 if_icmpgt、 if_icmple、 if_icmpge、 if_acmpeq和if_acmpne。
    复合条件分支：tableswitch、 lookupswitch。
    无条件分支：goto、 goto_w、 jsr、 jsr_w、 ret。

(8) 方法调用和返回指令
    invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。
    invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
    invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、 私有方法和父类方法。
    invokestatic指令用于调用类方法（static方法）。
    invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。

(9) 异常处理指令
    在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现

(10) 同步指令
    1、方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。 虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。
    2、同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的
    指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义

3 公有设计和私有实现
    Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。


